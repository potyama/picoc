ローカル変数のpush		PUSHL	n		(fp + n)番地の値をプッシュ
ローカル変数へのstore	STOREL	n		スタックトップをポップせずに(fp + n)に格納
一時領域へのstore		STORET	n		スタックトップをポップせずに(sp + n) に格納
グローバル変数のpush	(未定義)		いまのところ使わないので未定義
グローバル変数へのstore	(未定義)		いまのところ使わないので未定義
即値のpush				PUSHI	d		値 d をプッシュ
関数呼出し				CALL	label	label で示される番地をコール
リターン				RET				スタックトップの番地に復帰
スタックフレーム生成	ENTER			スタックフレームを生成
スタックフレーム解放	LEAVE			スタックフレームを解放
スタックポインタ移動	MVSP	n		SP を増減
分岐					JP		label	label で示される番地に無条件分岐
条件分岐(真)			JT		label	値をポップし非ゼロなら分岐
条件分岐(偽)			JF		label	値をポップしゼロなら分岐
算術演算				ADD				値を二つポップして演算結果をプッシュ
						SUB				   push(pop2 OP pop1)
						MUL
						DIV
						MOD
比較演算				EQ				値を二つポップして比較結果をプッシュ
						NE				  push(pop2 OP pop1)
						GT				  真なら 1，偽なら 0 をプッシュ
						GE
						LT
						LE
値の読み込み			RD				整数を読み込み，スタックにプッシュ
値の出力				WR				スタックから値をポップし画面に出力
改行					WRLN			改行する
実行停止				HALT			実行を停止する

スタック

	f()
	{
		int vf0,vf1, ... ,vfx;

		...
		r = g(式0, 式1, ... , 式n);
		...
	}

	関数 f 開始前のFP		old-FP			← 関数 f 実行中の FP
	関数 f の局所変数		Local vf0
							Local vf1
							...
							Local vfx		← 関数 f 開始時の SP
	関数 g の引数			Param 式0
							Param 式1
							...
							Param 式n-1
							Param 式n
	関数 g の戻り値			return-value
	復帰アドレス			return-address
	関数 g 開始前のFP		old-FP			← 関数 g 実行中の FP
	関数 g の局所変数		Local vg0
							Local vg1
							...
							Local vgy		← 関数 g 開始時の SP
							(以下，関数 g で式評価等に使用)

C では，関数呼出し時の実引数の評価順序は不定である(処理系が決めてよい)．
下向き構文解析をしながら直接コード生成するコンパイラでは，左から評価する
方が楽である．

一方，関数定義側ではスタックトップに近い方に一番左の引数がある方が，
オフセット計算が簡単になる．また，C の可変長引数を実現するためには，
一番左の引数の位置が分かっている必要があり，こちらの並びが適している．

裏技的な方法として，左から評価しておいてスタック上のデータを積み直す命令を
導入するというのもあるが，かなりいんちきくさい．

※引数の個数が分かっている場合の解決法

(1) SP を引数に必要な領域だけ成長させる
(2) 引数を左から順に計算し，しかるべきアドレスにストア
(3) 関数を呼ぶ

※戻り値の位置

関数 g への引数よりも上に戻り値領域をとれば，g から帰ってきたあと，
SP を動かす(引数分を足す)だけで，戻り値がスタックトップに残る．
可変長引数を許さないなら，この方が少し効率的
